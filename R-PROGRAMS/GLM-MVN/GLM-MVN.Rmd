---
title: "General Linear Model for Correlated Data: Dental Data"
output: html_document
---

```{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



This file pertains to the BIOS-767-Part-008 notes. 
```{r, message=FALSE,warning=FALSE}
## Load dental data
library(sas7bdat)
setwd('C:/Users/psioda/Documents/GitHub/bios-courses/BIOS-767/DATA/DENTAL')
dental.data = read.sas7bdat('dental.sas7bdat')
names(dental.data) = tolower(names(dental.data)) ## lowercase variable names
```


We begin by re-shaping the data from wide-to-long format, using the `tidyverse` package
```{r, message=FALSE,warning=FALSE}
library(tidyverse)
dental.long = pivot_longer(
  data = dental.data,
  cols = age8:age14,
  names_to = 'age',
  names_prefix = 'age',
  values_to = 'distance'
)
dental.long$age = as.numeric(dental.long$age)
head(dental.long)
```

### Match SE with SAS
The following function enables the computation of standard errors that match SAS (correct in all cases)
```{r, message=FALSE,warning=FALSE}
library(magic)
robust.cov <- function(u){
  form <-  formula(u)
  mf <- model.frame(form,getData(u))
  Xmat <- model.matrix(form,mf)
  ids <- unique(u$groups)
  m <- length(ids)
  Vlist <-  as.list(ids)
  for (i in 1:m){
    Vlist[[i]] <- getVarCov(u,individual=ids[i],type="marginal")
  }
  V <- Reduce(adiag,Vlist)
  Vinv <- solve(V)
  Sig.model <- solve(t(Xmat)%*%Vinv%*%Xmat)
  resid <- diag(residuals(u,type="response"))
  ones.list <- lapply(Vlist,FUN=function(u){matrix(1,nrow(u),ncol(u))})
  Ones <- Reduce(adiag,ones.list)
  meat <- t(Xmat)%*%Vinv%*%resid%*%Ones%*%resid%*%Vinv%*%Xmat
  Sig.robust <- Sig.model%*%meat%*%Sig.model
  se.robust <- sqrt(diag(Sig.robust))
  se.model <- sqrt(diag(Sig.model))
  return(list(Sig.model=Sig.model,se.model=se.model,Sig.robust=Sig.robust,se.robust=se.robust))
}
```



### First, we fit the regression model assuming unstructured covariance. 
### (compare to notes 008, Slide 18, DDFM corrected )
```{r, message = F, warning = F}
library(nlme)
fmla = distance ~ 0 + gender + age + gender*age

## REML (unstructured covariance)
  fit.reml = gls( 
    fmla, 
    correlation = corCompSymm(form = ~ 1 | id), 
    weights = varIdent(form = ~ 1 ),
    data = dental.long, 
    method = 'REML'
  )
  coef(summary(fit.reml))

  ## corrected
  nsub       <- length(unique(dental.long$id))
  beta.model <- coef(fit.reml)
  se.model   <- robust.cov(fit.reml)$se.model
  t.model    <- beta.model/se.model
  ddfm.model <- c(rep(nsub-2,2),rep(nrow(dental.long)-nsub-2,2))
  p.model    <- pt(-abs(t.model),ddfm.model)

  ## Organize results into table
  res.reml = data.frame(
            'Estimate' = beta.model, 
            'StdError' = se.model, 
            't' = t.model,
            'ddfm' = ddfm.model,
            'P-value' = p.model
            )

library(tidyverse)
library(kableExtra)
round(res.reml , 4) %>% 
    mutate_if(is.numeric, format, digits=4) %>% 
    kbl(caption = "Parameter Estimates Based on Maximum Likelihood" ) %>% 
    kable_styling('hover', full_width = T)
```

### Now we perform a test of parallelism.
### (compare to notes 008, Slide 16, DDFM corrected )
```{r, message = F}
  Sig.model   <- robust.cov(fit.reml)$Sig.model
  L <- c(0,0,0,1)
  
  L.beta     <- L%*%beta.model
  L.beta.cov <- L%*%Sig.model%*%L
  F.stat     <- L.beta%*%solve(L.beta.cov)%*%t(L.beta)
  ddfm       <- nrow(dental.long)-nrow(dental.data)-2
  prob.F <- pf(F.stat,df1=1,df2=ddfm,lower.tail=FALSE)

  parallel.reml <- data.frame(
            'F' = F.stat, 
            'P-value' = prob.F,
            'DDFM'    = ddfm
            )

library(tidyverse)
library(kableExtra)
round(parallel.reml , 4) %>% 
    mutate_if(is.numeric, format, digits=4) %>% 
    kbl(caption = "Test of Parallelism" ) %>% 
    kable_styling('hover', full_width = T)  
  
```


#### LRT
### (compare to notes 008, Slide 19, DDFM corrected )
The likelihood ratio test is easy to perform, and matches up precisely
with the SAS output.

```{r}

  fit.ml = gls( 
    distance ~ 0 + gender + gender:age, 
    correlation = corSymm(form = ~ 1 | id), 
    weights = varIdent(form = ~ 1 | age),
    data = dental.long, 
    method = 'ML'
  )

  fit.ml.red = gls( 
    distance ~ 0 + gender + age, 
    correlation = corSymm(form = ~ 1 | id), 
    weights = varIdent(form = ~ 1 | age),
    data = dental.long, 
    method = 'ML'
  )
anova(fit.ml, fit.ml.red)
```

### Interpolations
### (compare to notes 008, Slide 24, DDFM corrected )
Now, we predict male / female at various ages.
```{r}

fmla = distance ~ 0 + gender + gender:age

## REML (unstructured covariance)
  fit.interp = gls( 
    fmla, 
    correlation = corCompSymm(form = ~ 1 | id), 
    weights = varIdent(form = ~ 1 ),
    data = dental.long, 
    method = 'REML'
  )
  coef(summary(fit.interp))
  
  beta.interp <- coef(fit.interp)
  Sig.interp  <- Sig.model   <- robust.cov(fit.interp)$Sig.model
  
x.new            <- data.frame(female = c(rep(1,7), rep(0,7)),male = c(rep(0,7),rep(1,7)), f.age = c(8:14,rep(0,7)),m.age = c(rep(0,7),8:14))
x.pred           <- as.matrix(x.new)%*%c(beta.interp)
x.pred.se        <- sqrt(diag(as.matrix(x.new)%*%as.matrix(Sig.interp)%*%t(as.matrix(x.new))))
x.pred.limits    <- data.frame(female=x.new$female, male=x.new$male,female.slope=x.new$f.age,male.slope=x.new$m.age,
                              age=x.new$f.age+x.new$m.age,
                              est=x.pred, se=x.pred.se, lower=x.pred-qt(0.975,ddfm)*x.pred.se,upper=x.pred+qt(0.975,ddfm)*x.pred.se)
print(x.pred.limits)

ggp <- ggplot(x.pred.limits, aes(age, est)) + xlab("Age (Years)") + ylab("Distance") +
      ggtitle("Estimates and Point-wise 95% CIs for Gender-Specific Trajectories") + 
       geom_line(aes(colour=factor(female))) + guides(colour="none") +
       geom_ribbon(aes(ymin = lower, ymax = upper,fill=factor(female)),alpha=0.1) 
update_labels(ggp, list(fill="Gender (M=0;F=1)"))      
```



