---
title: "General Linear Model for Correlated Data: Dental Data"
output: html_document
---

```{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



This file pertains to the BIOS-767-Part-008 notes. 
```{r, message=FALSE,warning=FALSE}
## Load dental data
library(sas7bdat)
setwd('C:/Users/psioda/Documents/GitHub/bios-courses/BIOS-767/DATA/DENTAL')
dental.data = read.sas7bdat('dental.sas7bdat')
names(dental.data) = tolower(names(dental.data)) ## lowercase variable names
```


We begin by re-shaping the data from wide-to-long format, using the `tidyverse` package
```{r, message=FALSE,warning=FALSE}
library(tidyverse)
dental.long = pivot_longer(
  data = dental.data,
  cols = age8:age14,
  names_to = 'age',
  names_prefix = 'age',
  values_to = 'distance'
)
dental.long$age = as.numeric(dental.long$age)
head(dental.long)
```

### Match SE with SAS
The following function enables the computation of standard errors that match SAS (correct in all cases)
```{r, message=FALSE,warning=FALSE}
library(magic)
robust.cov <- function(u){
  form <-  formula(u)
  mf <- model.frame(form,getData(u))
  Xmat <- model.matrix(form,mf)
  ids <- unique(u$groups)
  m <- length(ids)
  Vlist <-  as.list(ids)
  for (i in 1:m){
    Vlist[[i]] <- getVarCov(u,individual=ids[i],type="marginal")
  }
  V <- Reduce(adiag,Vlist)
  Vinv <- solve(V)
  Sig.model <- solve(t(Xmat)%*%Vinv%*%Xmat)
  resid <- diag(residuals(u,type="response"))
  ones.list <- lapply(Vlist,FUN=function(u){matrix(1,nrow(u),ncol(u))})
  Ones <- Reduce(adiag,ones.list)
  meat <- t(Xmat)%*%Vinv%*%resid%*%Ones%*%resid%*%Vinv%*%Xmat
  Sig.robust <- Sig.model%*%meat%*%Sig.model
  se.robust <- sqrt(diag(Sig.robust))
  se.model <- sqrt(diag(Sig.model))
  return(list(Sig.model=Sig.model,se.model=se.model,Sig.robust=Sig.robust,se.robust=se.robust))
}
```



### First, we fit the regression model assuming compound symmetry.
```{r, message = F, warning = F}
library(nlme)
fmla = distance ~ 0 + gender + age + gender*age

## REML (unstructured covariance)
  fit.reml = gls( 
    fmla, 
    correlation = corCompSymm(form = ~ 1 | id), 
    weights = varIdent(form = ~ 1 ),
    data = dental.long, 
    method = 'REML'
  )
  coef(summary(fit.reml))

  ## corrected
  beta.model <- coef(fit.reml)
  se.model   <- robust.cov(fit.reml)$se.model
  t.model    <- beta.model/se.model
  p.model    <- pt(-abs(t.model),nrow(dental.data))

  ## Organize results into table
  res.reml = data.frame(
            'Estimate' = beta.model, 
            'StdError' = se.model, 
            't' = t.model, 
            'P-value' = p.model
            )

library(tidyverse)
library(kableExtra)
round(res.reml , 4) %>% 
    mutate_if(is.numeric, format, digits=4) %>% 
    kbl(caption = "Parameter Estimates Based on Maximum Likelihood" ) %>% 
    kable_styling('hover', full_width = T)
```

### Now we perform a test of parallelism.
```{r, message = F}
  Sig.model   <- robust.cov(fit.reml)$Sig.model
  L <- c(0,0,0,1)
  
  L.beta     <- L%*%beta.model
  L.beta.cov <- L%*%Sig.model%*%L
  F.stat     <- L.beta%*%solve(L.beta.cov)%*%t(L.beta)
  ddfm       <- nrow(dental.long)-nrow(dental.data)-2
  prob.F <- pf(F.stat,df1=1,df2=ddfm,lower.tail=FALSE)

  parallel.reml <- data.frame(
            'F' = F.stat, 
            'P-value' = prob.F,
            'DDFM'    = ddfm
            )

library(tidyverse)
library(kableExtra)
round(parallel.reml , 4) %>% 
    mutate_if(is.numeric, format, digits=4) %>% 
    kbl(caption = "Test of Parallelism" ) %>% 
    kable_styling('hover', full_width = T)  
  
```


#### LRT

The likelihood ratio test is easy to perform, and matches up precisely
with the SAS output.

```{r}

  fit.ml = gls( 
    distance ~ 0 + gender + gender:age, 
    correlation = corSymm(form = ~ 1 | id), 
    weights = varIdent(form = ~ 1 | age),
    data = dental.long, 
    method = 'ML'
  )

  fit.ml.red = gls( 
    distance ~ 0 + gender + age, 
    correlation = corSymm(form = ~ 1 | id), 
    weights = varIdent(form = ~ 1 | age),
    data = dental.long, 
    method = 'ML'
  )
anova(fit.ml, fit.ml.red)
```

### Interpolations
Now, we predict male / female at 11 years old. These numbers do not match up exactly. Moreover, there is no option for confidence limits.
```{r}
xnew = data.frame(gender = c('M', 'F'), age = c(11, 11))
pred = predict(fit.reml, newdata = xnew)
pred
```



