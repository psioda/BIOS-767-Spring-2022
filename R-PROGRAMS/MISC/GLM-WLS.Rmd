---
title: "Simulation / Analysis of Multivariate Normal Data"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Data simulation
We first set required input parameters.
```{r cars, message = F, error = F, warning = F}

set.seed(24141)

# number of subjects/visits per subject
nSub  <- 27
nVis  <-  4
t.vec <- c(8,10,12,14)

# model parameter values;
beta.vec <- c(21,22,0.2,0.2)

sd.mat   <- diag(c(4,4,4,4))
rho      <- 0.6
corr.mat <- (1-rho)*diag(nVis) + matrix(rho,nrow=nVis,ncol=nVis)
cov.mat  <- sd.mat%*%corr.mat%*%sd.mat 

print(corr.mat)
print(cov.mat)

```


Next, we generate the covariate matrix.
```{r, message = F, error = F, warning = F}

# generate covariates: 
# intercept (boy),   intercept (girl)
# linear time (boy), linear time (girl)
gender <- rep(rbinom(nSub,1,0.5),each=nVis)
id     <- rep(1:nSub,each=nVis)
time   <- rep(t.vec,nSub)
x      <- cbind((gender==0),(gender==1),(gender==0)*time,(gender==1)*time)
head(x,n=4)
tail(x,n=4)
```

Next, we generate the response vector by looping over subjects.
```{r, message = F, error = F, warning = F}
library(MASS)

y <- rep(0,nSub*nVis)
r <- 1;
for (i in 1:nSub)
{
  y[r:(r+nVis-1)] <- mvrnorm(n = 1, x[r:(r+nVis-1),]%*%beta.vec, cov.mat)
  r <- r + nVis;
}

head(cbind(y,x),n=4)
tail(cbind(y,x),n=4)

dat <-data.frame('id' <- id, 'y' <- y, 'gender' <- gender, 'time' <- time)
write.csv(dat,file='sim.Dat',row.names=FALSE)

```


Next, we code up a simple ML procedure assuming a common unstructured covariance
matrix for each subject. 
```{r, message = F, error = F, warning = F}

iteration <- 0
repeat
{
  ########################################################################
  # initialize to WLS estimates assuming W=identity matrix
  if (iteration==0)
  {
    beta.hat  <- solve(t(x)%*%x)%*%t(x)%*%y;
    ImP       <- diag(nrow(x)) - x%*%solve(t(x)%*%x)%*%t(x)
    W.hat     <- diag(c(t(y)%*%ImP%*%y / (nSub*nVis)),nrow=nVis,ncol=nVis)
    sigma.hat <- W.hat
  }
  
  # iterative process counter
  iteration = iteration + 1  
  
  # compute inverse of current W.hat value
  # to avoid repetitive computation
  iW <- solve(W.hat)
  
  ########################################################################
  # update beta.hat
  beta.old <- beta.hat
  
  t1 <- 0
  t2 <- 0
	for (i in 1:nSub)
	{	    
	   idx <- which(id==i);
			xi <- x[idx,];
			yi <- y[idx];

			t1 <- t1 + t(xi)%*%iW%*%xi;
			t2 <- t2 + t(xi)%*%iW%*%yi;
	}  
	it1         <- solve(t1)
	beta.hat    <- it1%*%t2
	change.beta <- max(abs(beta.hat-beta.old))
  ##########################################################
	
  ##########################################################
  # update sigma.hat (unstructured)
  sigma.old <- sigma.hat
  
  sigma.hat <- 0
	for (i in 1:nSub)
	{	    
	   idx <- which(id==i);
			xi <- x[idx,];
			yi <- y[idx];

		sigma.hat <- sigma.hat + 
		             (yi-xi%*%beta.hat)%*%t(yi-xi%*%beta.hat) 
	}
  sigma.hat    <- sigma.hat/nSub
	##########################################################
	
	##########################################################
	# compute variance parameters (compound symmetry)
	
	diag.term     <- 0
	off.diag.term <- 0
	n.obs         <- 0
	for (i in 1:nSub)
	{	 
	  # add up residuals
    for (idx.t1 in 1:nVis)
    {
	    idx <- which((id==i) & (time==t.vec[idx.t1]));
			 xi <- x[idx,];
		   yi <- y[idx];
		   ri1 <- c(yi-xi%*%beta.hat)
			
		  diag.term <- diag.term + ri1^2

      # add up cross-products
      for (idx.t2 in 1:nVis)
      {
        if (idx.t2>idx.t1)
        {
          idx <- which((id==i) & (time==t.vec[idx.t2]));
          xi <- x[idx,];
          yi <- y[idx];
          ri2 <- c(yi-xi%*%beta.hat)    
          
          off.diag.term <- off.diag.term + ri1*ri2
          n.obs <- n.obs + 1
        }
      }
    }
	}
	diag.term <- diag.term / (nSub*nVis - length(beta.hat))
	off.diag.term <- off.diag.term / (n.obs - length(beta.hat))
  ###########################################################	

	################################################
	# compute structured sigma.hat
	sigma.hat <- (diag.term-off.diag.term)*diag(nVis) + 
	             matrix(off.diag.term,nrow=nVis,ncol=nVis)
	change.sigma <- max(abs(sigma.hat-sigma.old))	
  iSigma <- solve(sigma.hat)
	################################################
	
	######################################################
	# compute covariance matrix for beta.hat (model-based)
  t1 <- 0
	for (i in 1:nSub)
	{	    
	   idx <- which(id==i);
			xi <- x[idx,];
			t1 <- t1 + t(xi)%*%iSigma%*%xi;
	}  
	cov.model  <- solve(t1)	
	#######################################################
	

	######################################################
	# compute covariance matrix for beta.hat (robust)
	iGamma.star <- solve(t1);
	
  t2 <- 0
	for (i in 1:nSub)
	{	    
	   idx <- which(id==i);
			xi <- x[idx,];
			yi <- y[idx];
		  ri <- c(yi-xi%*%beta.hat)
			t2 <- t2 + t(xi)%*%iSigma%*%ri%*%t(ri)%*%iSigma%*%xi;
	}  
  omega.star <- t2
  cov.robust <- iGamma.star%*%omega.star%*%iGamma.star
	#######################################################	
		
	
	
		
  if (iteration==100) break
	if (max(c(change.beta,change.sigma))<1e-10) break
}

## compute final correlation matrix
sigma.sd   <- sqrt(diag(sigma.hat))
sigma.corr <- diag(1/sigma.sd)%*%sigma.hat%*%diag(1/sigma.sd)
sigma.sd
sigma.corr

model.se  <- sqrt(diag(cov.model))
z.model   <- beta.hat / model.se
pv.model  <- 2*pnorm(abs(z.model), lower.tail = F)

## Organize results into table
res.model <- data.frame(
  'Estimate' = beta.hat, 'Model.SE' = model.se, 'Z.statistic' = z.model, 'P-value' = pv.model)


library(tidyverse)
library(kableExtra)
round(res.model , 4) %>% 
    mutate_if(is.numeric, format, digits=4) %>% 
    kbl(caption = "GEE Parameter Estimates / w Model-Based Standard Errors") %>% 
    kable_styling('hover', full_width = T) %>%
  footnote(general = paste("Algorithm converged after", iteration, "iterations. "),general_title = " " )


robust.se  <- sqrt(diag(cov.robust))
z.robust   <- beta.hat / robust.se
pv.robust  <- 2*pnorm(abs(z.robust), lower.tail = F)

## Organize results into table
res.robust <- data.frame(
  'Estimate' = beta.hat, 'Robust.SE' = robust.se, 'Z.statistic' = z.robust, 'P-value' = pv.robust)

library(tidyverse)
library(kableExtra)
round(res.robust, 4) %>% 
    mutate_if(is.numeric, format, digits=4) %>% 
    kbl(caption = "GEE Parameter Estimates / w Robust Standard Errors") %>% 
    kable_styling('hover', full_width = T) %>%
  footnote(general = paste("Algorithm converged after", iteration, "iterations. "),general_title = " " )
  
```


