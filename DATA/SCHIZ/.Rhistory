fhat_predict_1 <- predict(fhat_outer, x = log(y.h.pred1))
fhat_predict_2 <- predict(fhat_outer, x = log(y.h.pred2))
a0m[i,2]           <- mean(fhat_predict_1 <= fhat_predict_2)
}
}
tail(cbind(int0,t0,a0,a0m[,1],a0m[2,]))
tau <- 0.5 #quantile(c(t,t0)[which(c(nu,nu0)==1)],probs=0.5)
# reformat data
sim.dat <- data.frame(t  = c(t,t0),
nu = c(nu,nu0),
X1 = c(X1,Z1),
X2 = c(X2,Z2),
X3 = c(X3,Z3),
a0 =  c(rep(1,n),a0),
a01 = c(rep(1,n),a0m[,1]),
a02 = c(rep(1,n),a0m[,2]),
rand.wt = runif(n))
sim.split          <- survSplit(sim.dat,
cut = c(0, tau),
end = "t",
start = "t0",
event = "nu",
episode = "interval")
sim.split$interval <- factor(sim.split$interval - 1)
sim.split$expo     <- sim.split$t - sim.split$t0
sim.split$b0       <- sim.split$a01*(sim.split$interval==1) + sim.split$a02*(sim.split$interval==2)
head(sim.split)
tail(sim.split)
num <- data.frame(sim.split) %>%
group_by(interval) %>%
summarise(Freq = sum(a0*nu))
den <- data.frame(sim.split) %>%
group_by(interval) %>%
summarise(Freq = sum(a0*expo))
den[[length(den)]]
num[[length(num)]]
log(num[[length(num)]]/den[[length(den)]])
# fit models
sim.poisson.a0 <- glm(nu ~ interval + offset(log(expo)) + X2 + X3 - 1,
family = poisson(link = "log"),
data = sim.split,
weights = a0)
sim.poisson.b0 <- glm(nu ~ interval + offset(log(expo)) + X2 + X3 - 1,
family = poisson(link = "log"),
data = sim.split,
weights = b0)
sim.poisson.rand <- glm(nu ~ interval + offset(log(expo)) + X2 + X3 - 1,
family = poisson(link = "log"),
data = sim.split,
weights = rand.wt)
sim.poisson.5 <- glm(nu ~ interval + offset(log(expo)) + X2 + X3 - 1,
family = poisson(link = "log"),
data = sim.split,
weights = rep(0.5, nrow(sim.split)))
sim.poisson.1 <- glm(nu ~ interval + offset(log(expo)) + X2 + X3 - 1,
family = poisson(link = "log"),
data = sim.split)
sim.poisson.rct <- glm(nu ~ interval + offset(log(expo)) + X2 + X3 - 1,
family = poisson(link = "log"),
data = sim.split[which(sim.split$a0==1),])
sim.poisson.exp <- glm(nu ~ offset(log(t)) + X2 + X3,
family = poisson(link = "log"),
data = sim.dat,
weight = a0)
final <- data.frame(cbind(coef(sim.poisson.rct), sqrt(diag(vcov(sim.poisson.rct))),
coef(sim.poisson.1), sqrt(diag(vcov(sim.poisson.1))),
c(NA,coef(sim.poisson.exp)), c(NA,sqrt(diag(vcov(sim.poisson.exp)))),
coef(sim.poisson.5), sqrt(diag(vcov(sim.poisson.5))),
coef(sim.poisson.rand), sqrt(diag(vcov(sim.poisson.rand))),
coef(sim.poisson.a0), sqrt(diag(vcov(sim.poisson.a0))),
coef(sim.poisson.b0), sqrt(diag(vcov(sim.poisson.b0)))
))
names(final) <- c("nb_est", "nb_sd","pooling_est", "pooling_sd",
"exp_est", "exp_sd",
"wt_0.5_est", "wt_0.5_sd", "wt_rand_est", "wt_rand_sd",
"wt_a0_est", "wt_a0_sd", "wt_b0_est", "wt_b0_sd")
round(final, 3)
# plot 100 randomly selected subjects
plot(log(t[1:100]),
log(mean.surv[1:100]),
cex = a0*1.5,
xlab = "Observed (log scale)",
ylab = "Expected (log scale)")
mtext("Observed vs Expected Observation Time", side = 3, line = 2)
mtext("Size of Circle Proportional to Bayes p-value", side = 3, line = 1)
abline(a = 0, b = 1)
rm(list = ls())
library(MASS)
library(survival)
library(ks)
library(dplyr)
set.seed(45)
# generate data
n  <- 1E4
X1 <- rep(1, n)
X2 <- 0*rep(c(0, 1), each = n/2)
X3 <- 0*rnorm(n)
## simulate from piecewise exponential (break at 0.5)
.t<- matrix(rexp(2*n, rate = exp((1/2)*X1 + pi*X2 + 1.7*X3)),nrow=n,ncol=2)
t <- .t[,1]*(.t[,1]<0.5)+(0.5+.t[,2])*(.t[,1]>0.5)
nu <- rbinom(n, 1, 1) # all events
Z1 <- rep(1, n)
Z2 <- 0*rep(c(0, 1), each = n/2)
Z3 <- 0*rnorm(n)
## simulate from piecewise exponential (break at 0.5)
.t0  <- matrix(rexp(2*n, rate = exp((1/2)*Z1 + pi*Z2 + 1.7*Z3)),nrow=n,ncol=2)
t0  <- .t0[,1]*(.t0[,1]<0.5)+(0.5+.t0[,2])*(.t0[,1]>0.5)
int0 <- 1 +(.t0[,1]>0.5)
nu0 <- rbinom(n, 1, 1) # all events
# compatibility weights
mod <- survreg(Surv(t, nu) ~ X1 + X2 + X3 - 1, dist = "exponential")
lambda_mu <- coef(mod)
lambda_var <- vcov(mod)
mean.surv <- rep(NA, n)
lambda <- mvrnorm(1E4, mu = -lambda_mu, Sigma = lambda_var)
a0 <- rep(NA, n)
for (i in 1:n){
y.h.pred <- rexp(n, rate = exp(lambda[,1]*Z1[i] + lambda[,2]*Z2[i] + lambda[,3]*Z3[i]))
fhat_outer         <- kde(log(y.h.pred))
fhat_predict_outer <- predict(fhat_outer, x = log(y.h.pred))
a0[i] <- mean(fhat_predict_outer <= predict(fhat_outer, x = log(t0[i])))
mean.surv[i] <- mean(y.h.pred)
}
a0m <- matrix(0, nrow=n,ncol=2)
for (i in 1:n){
if (int0[i]==1)
{
y.h.pred           <- rexp(n, rate = exp(lambda[,1]*Z1[i] + lambda[,2]*Z2[i] + lambda[,3]*Z3[i]))
fhat_outer         <- kde(log(y.h.pred[which(y.h.pred<0.5)]))
fhat_predict_outer <- predict(fhat_outer, x = log(y.h.pred))
a0m[i,1]           <- mean(fhat_predict_outer <= predict(fhat_outer, x = log(t0[i])))
}
else
{
y.h.pred1          <- 0.5 + rexp(n, rate = exp(lambda[,1]*Z1[i] + lambda[,2]*Z2[i] + lambda[,3]*Z3[i]))
y.h.pred2          <- rexp(n, rate = exp(lambda[,1]*Z1[i] + lambda[,2]*Z2[i] + lambda[,3]*Z3[i]))
fhat_outer    <- kde(log(y.h.pred1))
fhat_predict_1 <- predict(fhat_outer, x = log(y.h.pred1))
fhat_predict_2 <- predict(fhat_outer, x = log(y.h.pred2))
a0m[i,2]           <- mean(fhat_predict_1 <= fhat_predict_2)
}
}
tail(cbind(int0,t0,a0,a0m[,1],a0m[2,]))
tau <- 0.5 #quantile(c(t,t0)[which(c(nu,nu0)==1)],probs=0.5)
# reformat data
sim.dat <- data.frame(t  = c(t,t0),
nu = c(nu,nu0),
X1 = c(X1,Z1),
X2 = c(X2,Z2),
X3 = c(X3,Z3),
a0 =  c(rep(1,n),a0),
a01 = c(rep(1,n),a0m[,1]),
a02 = c(rep(1,n),a0m[,2]),
rand.wt = runif(n))
sim.split          <- survSplit(sim.dat,
cut = c(0, tau),
end = "t",
start = "t0",
event = "nu",
episode = "interval")
sim.split$interval <- factor(sim.split$interval - 1)
sim.split$expo     <- sim.split$t - sim.split$t0
sim.split$b0       <- sim.split$a01*(sim.split$interval==1) + sim.split$a02*(sim.split$interval==2)
head(sim.split)
tail(sim.split)
num <- data.frame(sim.split) %>%
group_by(interval) %>%
summarise(Freq = sum(a0*nu))
den <- data.frame(sim.split) %>%
group_by(interval) %>%
summarise(Freq = sum(a0*expo))
den[[length(den)]]
num[[length(num)]]
log(num[[length(num)]]/den[[length(den)]])
# fit models
sim.poisson.a0 <- glm(nu ~ interval + offset(log(expo)) + X2 + X3 - 1,
family = poisson(link = "log"),
data = sim.split,
weights = a0)
sim.poisson.b0 <- glm(nu ~ interval + offset(log(expo)) + X2 + X3 - 1,
family = poisson(link = "log"),
data = sim.split,
weights = b0)
sim.poisson.rand <- glm(nu ~ interval + offset(log(expo)) + X2 + X3 - 1,
family = poisson(link = "log"),
data = sim.split,
weights = rand.wt)
sim.poisson.5 <- glm(nu ~ interval + offset(log(expo)) + X2 + X3 - 1,
family = poisson(link = "log"),
data = sim.split,
weights = rep(0.5, nrow(sim.split)))
sim.poisson.1 <- glm(nu ~ interval + offset(log(expo)) + X2 + X3 - 1,
family = poisson(link = "log"),
data = sim.split)
sim.poisson.rct <- glm(nu ~ interval + offset(log(expo)) + X2 + X3 - 1,
family = poisson(link = "log"),
data = sim.split[which(sim.split$a0==1),])
sim.poisson.exp <- glm(nu ~ offset(log(t)) + X2 + X3,
family = poisson(link = "log"),
data = sim.dat,
weight = a0)
final <- data.frame(cbind(coef(sim.poisson.rct), sqrt(diag(vcov(sim.poisson.rct))),
coef(sim.poisson.1), sqrt(diag(vcov(sim.poisson.1))),
c(NA,coef(sim.poisson.exp)), c(NA,sqrt(diag(vcov(sim.poisson.exp)))),
coef(sim.poisson.5), sqrt(diag(vcov(sim.poisson.5))),
coef(sim.poisson.rand), sqrt(diag(vcov(sim.poisson.rand))),
coef(sim.poisson.a0), sqrt(diag(vcov(sim.poisson.a0))),
coef(sim.poisson.b0), sqrt(diag(vcov(sim.poisson.b0)))
))
names(final) <- c("nb_est", "nb_sd","pooling_est", "pooling_sd",
"exp_est", "exp_sd",
"wt_0.5_est", "wt_0.5_sd", "wt_rand_est", "wt_rand_sd",
"wt_a0_est", "wt_a0_sd", "wt_b0_est", "wt_b0_sd")
round(final, 3)
# plot 100 randomly selected subjects
plot(log(t[1:100]),
log(mean.surv[1:100]),
cex = a0*1.5,
xlab = "Observed (log scale)",
ylab = "Expected (log scale)")
mtext("Observed vs Expected Observation Time", side = 3, line = 2)
mtext("Size of Circle Proportional to Bayes p-value", side = 3, line = 1)
abline(a = 0, b = 1)
rm(list = ls())
library(MASS)
library(survival)
library(ks)
library(dplyr)
set.seed(45)
# generate data
n  <- 1E4
X1 <- rep(1, n)
X2 <- 0*rep(c(0, 1), each = n/2)
X3 <- 0*rnorm(n)
## simulate from piecewise exponential (break at 0.5)
.t<- matrix(rexp(2*n, rate = exp((1/2)*X1 + pi*X2 + 1.7*X3)),nrow=n,ncol=2)
t <- .t[,1]*(.t[,1]<0.5)+(0.5+.t[,2])*(.t[,1]>0.5)
nu <- rbinom(n, 1, 1) # all events
Z1 <- rep(1, n)
Z2 <- 0*rep(c(0, 1), each = n/2)
Z3 <- 0*rnorm(n)
## simulate from piecewise exponential (break at 0.5)
.t0  <- matrix(rexp(2*n, rate = exp((1/2)*Z1 + pi*Z2 + 1.7*Z3)),nrow=n,ncol=2)
t0  <- .t0[,1]*(.t0[,1]<0.5)+(0.5+.t0[,2])*(.t0[,1]>0.5)
int0 <- 1 +(.t0[,1]>0.5)
nu0 <- rbinom(n, 1, 1) # all events
# compatibility weights
mod <- survreg(Surv(t, nu) ~ X1 + X2 + X3 - 1, dist = "exponential")
lambda_mu <- coef(mod)
lambda_var <- vcov(mod)
mean.surv <- rep(NA, n)
lambda <- mvrnorm(1E4, mu = -lambda_mu, Sigma = lambda_var)
a0 <- rep(NA, n)
for (i in 1:n){
y.h.pred <- rexp(n, rate = exp(lambda[,1]*Z1[i] + lambda[,2]*Z2[i] + lambda[,3]*Z3[i]))
fhat_outer         <- kde(log(y.h.pred))
fhat_predict_outer <- predict(fhat_outer, x = log(y.h.pred))
a0[i] <- mean(fhat_predict_outer <= predict(fhat_outer, x = log(t0[i])))
mean.surv[i] <- mean(y.h.pred)
}
a0m <- matrix(0, nrow=n,ncol=2)
for (i in 1:n){
if (int0[i]==1)
{
y.h.pred           <- rexp(n, rate = exp(lambda[,1]*Z1[i] + lambda[,2]*Z2[i] + lambda[,3]*Z3[i]))
fhat_outer         <- kde(log(y.h.pred[which(y.h.pred<0.5)]))
fhat_predict_outer <- predict(fhat_outer, x = log(y.h.pred))
a0m[i,1]           <- mean(fhat_predict_outer <= predict(fhat_outer, x = log(t0[i])))
}
else
{
y.h.pred1          <- 0.5 + rexp(n, rate = exp(lambda[,1]*Z1[i] + lambda[,2]*Z2[i] + lambda[,3]*Z3[i]))
y.h.pred2          <- rexp(n, rate = exp(lambda[,1]*Z1[i] + lambda[,2]*Z2[i] + lambda[,3]*Z3[i]))
fhat_outer    <- kde(log(y.h.pred1))
fhat_predict_1 <- predict(fhat_outer, x = log(y.h.pred1))
fhat_predict_2 <- predict(fhat_outer, x = log(y.h.pred2))
a0m[i,2]           <- mean(fhat_predict_1 <= fhat_predict_2)
}
}
tail(cbind(int0,t0,a0,a0m[,1],a0m[2,]))
tau <- 0.5 #quantile(c(t,t0)[which(c(nu,nu0)==1)],probs=0.5)
# reformat data
sim.dat <- data.frame(t  = c(t,t0),
nu = c(nu,nu0),
X1 = c(X1,Z1),
X2 = c(X2,Z2),
X3 = c(X3,Z3),
a0 =  c(rep(1,n),a0),
a01 = c(rep(1,n),a0m[,1]),
a02 = c(rep(1,n),a0m[,2]),
rand.wt = runif(n))
sim.split          <- survSplit(sim.dat,
cut = c(0, tau),
end = "t",
start = "t0",
event = "nu",
episode = "interval")
sim.split$interval <- factor(sim.split$interval - 1)
sim.split$expo     <- sim.split$t - sim.split$t0
sim.split$b0       <- sim.split$a01*(sim.split$interval==1) + sim.split$a02*(sim.split$interval==2)
head(sim.split)
tail(sim.split)
num <- data.frame(sim.split) %>%
group_by(interval) %>%
summarise(Freq = sum(a0*nu))
den <- data.frame(sim.split) %>%
group_by(interval) %>%
summarise(Freq = sum(a0*expo))
den[[length(den)]]
num[[length(num)]]
log(num[[length(num)]]/den[[length(den)]])
# fit models
sim.poisson.a0 <- glm(nu ~ interval + offset(log(expo)) + X2 + X3 - 1,
family = poisson(link = "log"),
data = sim.split,
weights = a0)
sim.poisson.b0 <- glm(nu ~ interval + offset(log(expo)) + X2 + X3 - 1,
family = poisson(link = "log"),
data = sim.split,
weights = b0)
sim.poisson.rand <- glm(nu ~ interval + offset(log(expo)) + X2 + X3 - 1,
family = poisson(link = "log"),
data = sim.split,
weights = rand.wt)
sim.poisson.5 <- glm(nu ~ interval + offset(log(expo)) + X2 + X3 - 1,
family = poisson(link = "log"),
data = sim.split,
weights = rep(0.5, nrow(sim.split)))
sim.poisson.1 <- glm(nu ~ interval + offset(log(expo)) + X2 + X3 - 1,
family = poisson(link = "log"),
data = sim.split)
sim.poisson.rct <- glm(nu ~ interval + offset(log(expo)) + X2 + X3 - 1,
family = poisson(link = "log"),
data = sim.split[which(sim.split$a0==1),])
sim.poisson.exp <- glm(nu ~ offset(log(t)) + X2 + X3,
family = poisson(link = "log"),
data = sim.dat,
weight = a0)
final <- data.frame(cbind(coef(sim.poisson.rct), sqrt(diag(vcov(sim.poisson.rct))),
coef(sim.poisson.1), sqrt(diag(vcov(sim.poisson.1))),
c(NA,coef(sim.poisson.exp)), c(NA,sqrt(diag(vcov(sim.poisson.exp)))),
coef(sim.poisson.5), sqrt(diag(vcov(sim.poisson.5))),
coef(sim.poisson.rand), sqrt(diag(vcov(sim.poisson.rand))),
coef(sim.poisson.a0), sqrt(diag(vcov(sim.poisson.a0))),
coef(sim.poisson.b0), sqrt(diag(vcov(sim.poisson.b0)))
))
names(final) <- c("nb_est", "nb_sd","pooling_est", "pooling_sd",
"exp_est", "exp_sd",
"wt_0.5_est", "wt_0.5_sd", "wt_rand_est", "wt_rand_sd",
"wt_a0_est", "wt_a0_sd", "wt_b0_est", "wt_b0_sd")
round(final, 3)
# plot 100 randomly selected subjects
plot(log(t[1:100]),
log(mean.surv[1:100]),
cex = a0*1.5,
xlab = "Observed (log scale)",
ylab = "Expected (log scale)")
mtext("Observed vs Expected Observation Time", side = 3, line = 2)
mtext("Size of Circle Proportional to Bayes p-value", side = 3, line = 1)
abline(a = 0, b = 1)
rm(list = ls())
library(MASS)
library(survival)
library(ks)
library(dplyr)
set.seed(45)
# generate data
n  <- 1E4
X1 <- rep(1, n)
X2 <- 0*rep(c(0, 1), each = n/2)
X3 <- 0*rnorm(n)
## simulate from piecewise exponential (break at 0.5)
.t<- matrix(rexp(2*n, rate = exp((1/2)*X1 + pi*X2 + 1.7*X3)),nrow=n,ncol=2)
t <- .t[,1]*(.t[,1]<0.5)+(0.5+.t[,2])*(.t[,1]>0.5)
nu <- rbinom(n, 1, 1) # all events
Z1 <- rep(1, n)
Z2 <- 0*rep(c(0, 1), each = n/2)
Z3 <- 0*rnorm(n)
## simulate from piecewise exponential (break at 0.5)
.t0  <- matrix(rexp(2*n, rate = exp((1/2)*Z1 + pi*Z2 + 1.7*Z3)),nrow=n,ncol=2)
t0  <- .t0[,1]*(.t0[,1]<0.5)+(0.5+.t0[,2])*(.t0[,1]>0.5)
int0 <- 1 +(.t0[,1]>0.5)
nu0 <- rbinom(n, 1, 1) # all events
# compatibility weights
mod <- survreg(Surv(t, nu) ~ X1 + X2 + X3 - 1, dist = "exponential")
lambda_mu <- coef(mod)
lambda_var <- vcov(mod)
mean.surv <- rep(NA, n)
lambda <- mvrnorm(1E4, mu = -lambda_mu, Sigma = lambda_var)
a0 <- rep(NA, n)
for (i in 1:n){
y.h.pred <- rexp(n, rate = exp(lambda[,1]*Z1[i] + lambda[,2]*Z2[i] + lambda[,3]*Z3[i]))
fhat_outer         <- kde(log(y.h.pred))
fhat_predict_outer <- predict(fhat_outer, x = log(y.h.pred))
a0[i] <- mean(fhat_predict_outer <= predict(fhat_outer, x = log(t0[i])))
mean.surv[i] <- mean(y.h.pred)
}
a0m <- matrix(0, nrow=n,ncol=2)
for (i in 1:n){
if (int0[i]==1)
{
y.h.pred           <- rexp(n, rate = exp(lambda[,1]*Z1[i] + lambda[,2]*Z2[i] + lambda[,3]*Z3[i]))
fhat_outer         <- kde(log(y.h.pred[which(y.h.pred<0.5)]))
fhat_predict_outer <- predict(fhat_outer, x = log(y.h.pred))
a0m[i,1]           <- mean(fhat_predict_outer <= predict(fhat_outer, x = log(t0[i])))
}
else
{
y.h.pred1          <- 0.5 + rexp(n, rate = exp(lambda[,1]*Z1[i] + lambda[,2]*Z2[i] + lambda[,3]*Z3[i]))
y.h.pred2          <- rexp(n, rate = exp(lambda[,1]*Z1[i] + lambda[,2]*Z2[i] + lambda[,3]*Z3[i]))
fhat_outer    <- kde(log(y.h.pred1))
fhat_predict_1 <- predict(fhat_outer, x = log(y.h.pred1))
fhat_predict_2 <- predict(fhat_outer, x = log(y.h.pred2))
a0m[i,2]           <- mean(fhat_predict_1 <= fhat_predict_2)
}
}
tail(cbind(int0,t0,a0,a0m[,1],a0m[2,]))
tau <- 0.5 #quantile(c(t,t0)[which(c(nu,nu0)==1)],probs=0.5)
# reformat data
sim.dat <- data.frame(t  = c(t,t0),
nu = c(nu,nu0),
X1 = c(X1,Z1),
X2 = c(X2,Z2),
X3 = c(X3,Z3),
a0 =  c(rep(1,n),a0),
a01 = c(rep(1,n),a0m[,1]),
a02 = c(rep(1,n),a0m[,2]),
rand.wt = runif(n))
sim.split          <- survSplit(sim.dat,
cut = c(0, tau),
end = "t",
start = "t0",
event = "nu",
episode = "interval")
sim.split$interval <- factor(sim.split$interval - 1)
sim.split$expo     <- sim.split$t - sim.split$t0
sim.split$b0       <- sim.split$a01*(sim.split$interval==1) + sim.split$a02*(sim.split$interval==2)
head(sim.split)
tail(sim.split)
num <- data.frame(sim.split) %>%
group_by(interval) %>%
summarise(Freq = sum(a0*nu))
den <- data.frame(sim.split) %>%
group_by(interval) %>%
summarise(Freq = sum(a0*expo))
den[[length(den)]]
num[[length(num)]]
log(num[[length(num)]]/den[[length(den)]])
# fit models
sim.poisson.a0 <- glm(nu ~ interval + offset(log(expo)) + X2 + X3 - 1,
family = poisson(link = "log"),
data = sim.split,
weights = a0)
sim.poisson.b0 <- glm(nu ~ interval + offset(log(expo)) + X2 + X3 - 1,
family = poisson(link = "log"),
data = sim.split,
weights = b0)
sim.poisson.rand <- glm(nu ~ interval + offset(log(expo)) + X2 + X3 - 1,
family = poisson(link = "log"),
data = sim.split,
weights = rand.wt)
sim.poisson.5 <- glm(nu ~ interval + offset(log(expo)) + X2 + X3 - 1,
family = poisson(link = "log"),
data = sim.split,
weights = rep(0.5, nrow(sim.split)))
sim.poisson.1 <- glm(nu ~ interval + offset(log(expo)) + X2 + X3 - 1,
family = poisson(link = "log"),
data = sim.split)
sim.poisson.rct <- glm(nu ~ interval + offset(log(expo)) + X2 + X3 - 1,
family = poisson(link = "log"),
data = sim.split[which(sim.split$a0==1),])
sim.poisson.exp <- glm(nu ~ offset(log(t)) + X2 + X3,
family = poisson(link = "log"),
data = sim.dat,
weight = a0)
final <- data.frame(cbind(coef(sim.poisson.rct), sqrt(diag(vcov(sim.poisson.rct))),
coef(sim.poisson.1), sqrt(diag(vcov(sim.poisson.1))),
c(NA,coef(sim.poisson.exp)), c(NA,sqrt(diag(vcov(sim.poisson.exp)))),
coef(sim.poisson.5), sqrt(diag(vcov(sim.poisson.5))),
coef(sim.poisson.rand), sqrt(diag(vcov(sim.poisson.rand))),
coef(sim.poisson.a0), sqrt(diag(vcov(sim.poisson.a0))),
coef(sim.poisson.b0), sqrt(diag(vcov(sim.poisson.b0)))
))
names(final) <- c("nb_est", "nb_sd","pooling_est", "pooling_sd",
"exp_est", "exp_sd",
"wt_0.5_est", "wt_0.5_sd", "wt_rand_est", "wt_rand_sd",
"wt_a0_est", "wt_a0_sd", "wt_b0_est", "wt_b0_sd")
round(final, 3)
# plot 100 randomly selected subjects
plot(log(t[1:100]),
log(mean.surv[1:100]),
cex = a0*1.5,
xlab = "Observed (log scale)",
ylab = "Expected (log scale)")
mtext("Observed vs Expected Observation Time", side = 3, line = 2)
mtext("Size of Circle Proportional to Bayes p-value", side = 3, line = 1)
abline(a = 0, b = 1)
## compare to SAS Proc GENMOD;
gee.fit = ordgee( ordered(factor(y234)) ~ factor(trt)*factor(week), id = id, data = schiz, corstr = "independence", int.const=TRUE)
setwd("C:/Users/psioda/Documents/GitHub/bios-courses/BIOS-767/DATA/SCHIZ");
### GEE analysis - PO model;
### note that for this data set, the GEE algorithm
### does not converge unless y is mapped according to h(1,2) = 2;
schiz           <- read.table("schiz.txt",header=F)
colnames(schiz) <- c("id","y","trt","week");
schiz           <- tibble(schiz) %>% filter(week %in% c(0,1,3,6))
schiz$y234      <- ifelse(schiz$y<=2,2,schiz$y)
schiz$times     <- as.numeric(factor(schiz$week,levels=unique(factor(schiz$week))))
schiz$id        <- as.integer(as.numeric(factor(schiz$id,levels=unique(factor(schiz$id)))))
## compare to SAS Proc GENMOD;
gee.fit = ordgee( ordered(factor(y234)) ~ factor(trt)*factor(week), id = id, data = schiz, corstr = "independence", int.const=TRUE)
gee.fit
